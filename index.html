<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>かんたん文字起こし（メーター付・ワンクリ保存＆コピー）</title>
<style>
  :root{ --bg:#f6f9fc; --card:#fff; --ink:#0f172a; --muted:#64748b; --accent:#2563eb; }
  html,body{margin:0;height:100%;font-family:system-ui,-apple-system,"Segoe UI",sans-serif;background:var(--bg);color:var(--ink)}
  header{position:sticky;top:0;background:rgba(255,255,255,.9);backdrop-filter:saturate(1.2) blur(6px);border-bottom:1px solid #e6eef7}
  .wrap{max-width:1100px;margin:auto;padding:16px}
  h1{font-size:20px;margin:8px 0}
  .toolbar{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0 12px}
  button{appearance:none;border:1px solid #dbe7f5;background:#fff;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
  button.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  button.danger{background:#ef4444;border-color:#ef4444;color:#fff}
  button:disabled{opacity:.5;cursor:not-allowed}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .badge{font-size:12px;padding:2px 8px;border-radius:999px;background:#eef6ff;color:#2563eb;border:1px solid #cfe3ff}

  .panel{background:var(--card);border:1px solid #e6eef7;border-radius:16px;padding:14px}
  .meters{display:grid;grid-template-columns:120px 1fr;gap:16px;align-items:center;margin:6px 0 14px}
  .mic-bubble{width:90px;height:90px;border-radius:999px;background:#e6f0ff;border:2px solid #cfe3ff;display:grid;place-items:center;transition:transform .08s linear, box-shadow .1s linear;box-shadow:0 0 0 rgba(37,99,235,.0)}
  .mic-bubble.on{box-shadow:0 0 24px rgba(37,99,235,.35)}
  .mic-dot{width:16px;height:16px;border-radius:999px;background:#2563eb}
  .bar-wrap{height:14px;border-radius:999px;background:#eef3fb;overflow:hidden;border:1px solid #dbe7f5}
  .bar{height:100%;width:0%;background:#2563eb;transition:width .08s linear}
  #wave{width:100%;height:70px;display:block;background:#fafcff;border:1px dashed #dbe7f5;border-radius:10px}

  #log{white-space:pre-wrap;line-height:1.6}
  .seg{margin:0 0 10px;border-left:3px solid #dbe7f5;padding-left:10px}
  .seg .ts{color:var(--muted);font-size:12px;margin-right:6px}
  .seg .final{color:#0f172a}
  .seg .interim{color:#6b7280}

  footer{padding:20px 0 60px;color:var(--muted);text-align:center}
</style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>かんたん文字起こし（Web Speech / ローカル保存 / メーター付）</h1>
      <div class="toolbar">
        <button id="btnStart" class="primary">🎙️ 開始</button>
        <button id="btnPause" disabled>⏸ 一時停止</button>
        <button id="btnResume" disabled>▶ 再開</button>
        <button id="btnStop" class="danger" disabled>■ 停止</button>
        <button id="btnQuickSave" title="現在の文字起こしをローカルにスナップショット保存">💾 保存</button>
        <button id="btnCopy" title="現在の文字起こしを丸ごとクリップボードへコピー">📋 コピー</button>
        <span class="badge" id="status">待機中</span>
      </div>
      <div class="row">
        <span class="badge">自動バックアップ: 10秒ごと</span>
        <span class="badge">推奨: Chrome / Edge</span>
        <span class="badge">長時間対応: 自動再起動</span>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div class="panel">
      <div class="meters">
        <div class="mic-bubble" id="micBubble"><div class="mic-dot"></div></div>
        <div>
          <div class="bar-wrap"><div class="bar" id="levelBar"></div></div>
          <canvas id="wave"></canvas>
        </div>
      </div>
      <div id="log"></div>
    </div>
  </main>

  <footer>
    使い方: 開始→話す→メーターが動けば入力中 → 必要に応じて「💾保存」or「📋コピー」。<br/>
    ※ iOS Safari はリアルタイム認識不可（録音のみ可）。高精度は保存音声の後処理推奨。
  </footer>

<script>
(() => {
  let recognizing = false, paused = false, recognizer = null, interimSpan = null, startTime = null;
  let micStream = null, audioCtx = null, analyser = null, timeData = null, rafId = null;

  const $ = (id) => document.getElementById(id);
  const logEl = $('log'), statusEl = $('status'), levelBar = $('levelBar'), micBubble = $('micBubble');
  const wave = $('wave'), wctx = wave.getContext('2d');
  const btnStart = $('btnStart'), btnPause = $('btnPause'), btnResume = $('btnResume'), btnStop = $('btnStop');
  const btnQuickSave = $('btnQuickSave'), btnCopy = $('btnCopy');

  const fmtTS = (ms) => { const s = Math.floor(ms/1000); const hh=String(Math.floor(s/3600)).padStart(2,'0'), mm=String(Math.floor((s%3600)/60)).padStart(2,'0'), ss=String(s%60).padStart(2,'0'); return `${hh}:${mm}:${ss}`; };
  const nowTS = () => startTime ? fmtTS(Date.now() - startTime) : '00:00:00';

  const addSegment = (text, {interim=false}={}) => {
    const seg = document.createElement('div'); seg.className = 'seg';
    const ts = document.createElement('span'); ts.className='ts'; ts.textContent = `[${nowTS()}]`;
    const body = document.createElement('span'); body.className = interim ? 'interim' : 'final'; body.textContent = text;
    seg.appendChild(ts); seg.appendChild(body); logEl.appendChild(seg);
    interimSpan = interim ? body : null;
    seg.scrollIntoView({behavior:'smooth', block:'end'});
    backupSave();
  };
  const replaceInterim = (text) => { interimSpan ? interimSpan.textContent = text : addSegment(text, {interim:true}); };
  const setStatus = (txt) => statusEl.textContent = txt;

  function backupSave(){ localStorage.setItem('transcript_html_v1', logEl.innerHTML); }
  function backupLoad(){ const html = localStorage.getItem('transcript_html_v1'); if (html) logEl.innerHTML = html; }
  setInterval(() => { if (recognizing || logEl.innerHTML) backupSave(); }, 10000);

  function quickSaveSnapshot(){
    const text = buildPlainText();
    const id = new Date().toISOString();
    const item = { id, savedAt:id, text, html: logEl.innerHTML };
    const key='transcript_snapshots_v1';
    const arr = JSON.parse(localStorage.getItem(key) || '[]'); arr.push(item);
    localStorage.setItem(key, JSON.stringify(arr));
    flash('保存しました');
  }

  function buildPlainText(){
    return Array.from(logEl.querySelectorAll('.seg')).map(seg=>{
      const ts = seg.querySelector('.ts')?.textContent ?? '';
      const body = seg.querySelector('.final, .interim')?.textContent ?? '';
      return `${ts} ${body}`.trim();
    }).join('\n');
  }

  async function copyAll(){
    const text = buildPlainText();
    try{
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
      } else {
        // フォールバック
        const ta = document.createElement('textarea'); ta.value = text; document.body.appendChild(ta);
        ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
      }
      flash('コピーしました');
    }catch(e){
      console.error(e); flash('コピーに失敗しました');
    }
  }

  function flash(msg){
    const old = statusEl.textContent;
    setStatus(msg);
    setTimeout(()=> setStatus(recognizing ? '認識中...' : '待機中'), 1500);
  }

  async function initMicAndMeters(){
    if (micStream) return micStream;
    micStream = await navigator.mediaDevices.getUserMedia({ audio:{ echoCancellation:true, noiseSuppression:true } });
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    const source = audioCtx.createMediaStreamSource(micStream);
    analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048; timeData = new Uint8Array(analyser.fftSize); source.connect(analyser);

    wave.width = wave.clientWidth * devicePixelRatio; wave.height = wave.clientHeight * devicePixelRatio;
    const loop = () => {
      analyser.getByteTimeDomainData(timeData);
      let sum=0; for(let i=0;i<timeData.length;i++){ const v=(timeData[i]-128)/128; sum+=v*v; }
      const rms = Math.sqrt(sum/timeData.length), level = Math.min(1, rms*4);
      levelBar.style.width = (level*100).toFixed(0)+'%';
      micBubble.classList.toggle('on', level>0.04);
      micBubble.style.transform = `scale(${(1+Math.min(0.25, level*0.8)).toFixed(3)})`;

      const W=wave.width,H=wave.height,mid=H/2; const ctx=wctx; ctx.clearRect(0,0,W,H); ctx.lineWidth=2*devicePixelRatio; ctx.strokeStyle='#2563eb';
      ctx.beginPath(); const step=Math.ceil(timeData.length/W);
      for(let x=0,i=0;x<W;x++,i+=step){ const yv=(timeData[Math.min(i,timeData.length-1)]-128)/128; const y=mid + yv*(H/2-4*devicePixelRatio); if(x===0)ctx.moveTo(x,y); else ctx.lineTo(x,y); }
      ctx.stroke();

      rafId = requestAnimationFrame(loop);
    };
    rafId = requestAnimationFrame(loop);
    return micStream;
  }

  function stopMicAndMeters(){
    if (rafId) cancelAnimationFrame(rafId), rafId=null;
    if (audioCtx) audioCtx.close().catch(()=>{});
    micBubble.style.transform='scale(1)'; micBubble.classList.remove('on');
  }

  function createRecognizer(){
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR){ alert('このブラウザは Web Speech API に未対応です。Chrome/Edge をお試しください。'); return null; }
    const r = new SR(); r.lang='ja-JP'; r.interimResults=true; r.continuous=true; r.maxAlternatives=1;
    r.onstart = ()=> setStatus('認識中...');
    r.onend   = ()=> { setStatus(paused ? '一時停止中' : (recognizing ? '再起動中...' : '停止')); if (recognizing && !paused) setTimeout(()=>{try{r.start();}catch{}} ,200); };
    r.onerror = (e)=> { console.warn('Speech error:', e); setStatus('エラー: '+(e.error||'unknown')); if (recognizing && !paused) setTimeout(()=>{try{r.start();}catch{}} ,400); };
    r.onresult= (ev)=> {
      let interim=''; for(let i=ev.resultIndex;i<ev.results.length;i++){ const res=ev.results[i], txt=res[0].transcript; if(res.isFinal) addSegment(txt.trim(), {interim:false}); else interim+=txt; }
      if (interim) replaceInterim(interim);
    };
    return r;
  }

  btnStart.onclick = async () => {
    if (recognizing) return;
    backupLoad(); startTime = Date.now();
    try { await initMicAndMeters(); } catch(e){ alert('マイク権限をご確認ください（🔒→サイトの設定）。'); console.error(e); return; }
    recognizer = createRecognizer(); if (!recognizer) return;
    recognizing = true; paused=false;
    btnStart.disabled=true; btnPause.disabled=false; btnResume.disabled=true; btnStop.disabled=false;
    try{ recognizer.start(); }catch(e){}
    setStatus('認識中...');
  };
  btnPause.onclick = () => { if (!recognizing || paused) return; paused=true; try{recognizer.stop();}catch{} setStatus('一時停止中'); btnPause.disabled=true; btnResume.disabled=false; };
  btnResume.onclick= () => { if (!recognizing || !paused) return; paused=false; try{recognizer.start();}catch{} setStatus('認識中...'); btnPause.disabled=false; btnResume.disabled=true; };
  btnStop.onclick   = () => { recognizing=false; paused=false; try{recognizer.stop();}catch{} stopMicAndMeters(); btnStart.disabled=false; btnPause.disabled=true; btnResume.disabled=true; btnStop.disabled=true; setStatus('停止'); backupSave(); };

  btnQuickSave.onclick = () => quickSaveSnapshot();
  btnCopy.onclick = () => copyAll();

  backupLoad();
})();
</script>
</body>
</html>
