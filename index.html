<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>かんたん文字おこし（日本語固定・マイク選択・メーター・保存/コピー/削除・重複防止）</title>
<style>
  :root{ --bg:#f6f9fc; --card:#fff; --ink:#0f172a; --muted:#64748b; --accent:#2563eb; }
  html,body{margin:0;height:100%;font-family:system-ui,-apple-system,"Segoe UI",sans-serif;background:var(--bg);color:var(--ink)}
  header{position:sticky;top:0;background:rgba(255,255,255,.9);backdrop-filter:saturate(1.2) blur(6px);border-bottom:1px solid #e6eef7;z-index:10}
  .wrap{max-width:1100px;margin:auto;padding:16px}
  h1{font-size:20px;margin:8px 0}
  h2{font-size:16px;margin:0 0 6px}
  .toolbar{display:flex;flex-wrap:wrap;gap:8px;margin:8px 0 12px}
  button{appearance:none;border:1px solid #dbe7f5;background:#fff;border-radius:10px;padding:10px 14px;font-weight:700;cursor:pointer}
  button.primary{background:var(--accent);border-color:var(--accent);color:#fff}
  button.danger{background:#ef4444;border-color:#ef4444;color:#fff}
  button:disabled{opacity:.5;cursor:not-allowed}
  select{border:1px solid #dbe7f5;border-radius:10px;padding:10px 12px;background:#fff}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .badge{font-size:12px;padding:2px 8px;border-radius:999px;background:#eef6ff;color:var(--accent);border:1px solid #cfe3ff}
  .panel{background:var(--card);border:1px solid #e6eef7;border-radius:16px;padding:14px;margin:12px 0}
  .meters{display:grid;grid-template-columns:120px 1fr;gap:16px;align-items:center;margin:6px 0 14px}
  .mic-bubble{width:90px;height:90px;border-radius:999px;background:#e6f0ff;border:2px solid #cfe3ff;display:grid;place-items:center;transition:transform .08s linear, box-shadow .1s linear;box-shadow:0 0 0 rgba(37,99,235,.0)}
  .mic-bubble.on{box-shadow:0 0 24px rgba(37,99,235,.35)}
  .mic-dot{width:16px;height:16px;border-radius:999px;background:#2563eb}
  .bar-wrap{height:14px;border-radius:999px;background:#eef3fb;overflow:hidden;border:1px solid #dbe7f5}
  .bar{height:100%;width:0%;background:#2563eb;transition:width .08s linear}
  #wave{width:100%;height:70px;display:block;background:#fafcff;border:1px dashed #dbe7f5;border-radius:10px}
  #log{white-space:pre-wrap;line-height:1.6}
  .seg{margin:0 0 10px;border-left:3px solid #dbe7f5;padding-left:10px}
  .seg .ts{color:var(--muted);font-size:12px;margin-right:6px}
  .seg .final{color:#0f172a}
  .seg .interim{color:#6b7280}
  .note{font-size:12px;color:var(--muted)}
  footer{padding:20px 0 60px;color:var(--muted);text-align:center}
</style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>かんたん文字おこし</h1>
      <div class="toolbar">
        <button id="btnStart" class="primary">🎙️ 開始</button>
        <button id="btnPause" disabled>⏸ 一時停止</button>
        <button id="btnResume" disabled>▶ 再開</button>
        <button id="btnStop" class="danger" disabled>■ 停止</button>
        <button id="btnQuickSave" title="現在の文字をローカルにスナップショット保存">💾 保存</button>
        <button id="btnCopy" title="現在の文字をコピー">📋 コピー</button>
        <button id="btnClear" class="danger" title="全消去">🗑 削除</button>
        <span class="badge" id="status">待機中</span>
      </div>
      <div class="row">
        <label class="badge" style="background:#fff">🎤 マイク:
          <select id="micSelect" style="margin-left:6px"></select>
        </label>
        <span class="badge">日本語固定（ja-JP）</span>
        <span class="badge">推奨: PC Chrome / Edge</span>
      </div>
    </div>
  </header>

  <main class="wrap">
    <div class="panel">
      <h2>リアルタイム（Web Speech API）</h2>
      <p class="note">iOS Safari はリアルタイム認識に未対応（録音は可）。このページを開いたままご利用ください。</p>
      <div class="meters">
        <div class="mic-bubble" id="micBubble"><div class="mic-dot"></div></div>
        <div>
          <div class="bar-wrap"><div class="bar" id="levelBar"></div></div>
          <canvas id="wave"></canvas>
        </div>
      </div>
      <div id="log"></div>
    </div>
  </main>

  <footer>
    🎙️ 開始 → マイク許可 → メーターが動けば入力中。<br/>
    同じ文が2回出る現象を防ぐため、暫定行の昇格と直近finalのデデュープを実装済みです。
  </footer>

<script>
(() => {
  // ===== 状態 =====
  let recognizing=false, paused=false, recognizer=null;
  let interimSegEl=null, interimBodyEl=null;  // 暫定表示の要素
  let lastFinalText='', lastFinalAt=0;        // 直近finalの重複防止
  let startTime=null;
  let micStream=null, audioCtx=null, analyser=null, timeData=null, rafId=null;
  let retryCount=0; const MAX_RETRY=6;
  let lastResultAt=Date.now();

  // 要素
  const $=id=>document.getElementById(id);
  const logEl=$('log'), statusEl=$('status'), levelBar=$('levelBar'), micBubble=$('micBubble');
  const wave=$('wave'), wctx=wave.getContext('2d');
  const btnStart=$('btnStart'), btnPause=$('btnPause'), btnResume=$('btnResume'), btnStop=$('btnStop');
  const btnQuickSave=$('btnQuickSave'), btnCopy=$('btnCopy'), btnClear=$('btnClear');
  const micSelect=$('micSelect');

  // ===== ユーティリティ =====
  const fmtTS=ms=>{const s=Math.floor(ms/1000);return`${String(Math.floor(s/3600)).padStart(2,'0')}:${String(Math.floor((s%3600)/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`};
  const nowTS=()=>startTime?fmtTS(Date.now()-startTime):'00:00:00';
  const setStatus=txt=>statusEl.textContent=txt;

  function addSegment(text,{interim=false}={}) {
    const seg=document.createElement('div'); seg.className='seg';
    const ts=document.createElement('span'); ts.className='ts'; ts.textContent=`[${nowTS()}]`;
    const body=document.createElement('span'); body.className=interim?'interim':'final'; body.textContent=text;
    seg.appendChild(ts); seg.appendChild(body); logEl.appendChild(seg);

    if (interim) { interimSegEl=seg; interimBodyEl=body; }
    else { interimSegEl=null; interimBodyEl=null; }

    seg.scrollIntoView({behavior:'smooth', block:'end'});
    backupSave();
  }

  function replaceInterim(text) {
    if (interimBodyEl) {
      interimBodyEl.textContent = text;
    } else {
      addSegment(text, { interim: true });
    }
  }

  function backupSave(){ localStorage.setItem('transcript_html_v1', logEl.innerHTML); }
  function backupLoad(){ const html=localStorage.getItem('transcript_html_v1'); if (html) logEl.innerHTML = html; }
  setInterval(()=>{ if(recognizing || logEl.innerHTML) backupSave(); }, 10000);

  function quickSaveSnapshot(){
    const text = Array.from(logEl.querySelectorAll('.seg')).map(seg=>{
      const ts=seg.querySelector('.ts')?.textContent??''; const body=seg.querySelector('.final,.interim')?.textContent??'';
      return `${ts} ${body}`.trim();
    }).join('\n');
    const id=new Date().toISOString();
    const item={ id, savedAt:id, text, html:logEl.innerHTML };
    const key='transcript_snapshots_v1';
    const arr=JSON.parse(localStorage.getItem(key) || '[]'); arr.push(item);
    localStorage.setItem(key, JSON.stringify(arr));
    flash('保存しました');
  }

  async function copyAll(){
    const text = Array.from(logEl.querySelectorAll('.seg')).map(seg=>{
      const ts=seg.querySelector('.ts')?.textContent??''; const body=seg.querySelector('.final,.interim')?.textContent??'';
      return `${ts} ${body}`.trim();
    }).join('\n');
    try{
      if (navigator.clipboard?.writeText) await navigator.clipboard.writeText(text);
      else {
        const ta=document.createElement('textarea'); ta.value=text; document.body.appendChild(ta);
        ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
      }
      flash('コピーしました');
    } catch(e) {
      console.error(e); flash('コピー失敗');
    }
  }

  function flash(msg){ setStatus(msg); setTimeout(()=> setStatus(recognizing ? '認識中...' : '待機中'), 1500); }

  // ===== デバイス選択 =====
  async function listMics(){
    try { await navigator.mediaDevices.getUserMedia({ audio:true }); } catch(_) {}
    const devices = await navigator.mediaDevices.enumerateDevices();
    const mics = devices.filter(d=>d.kind==='audioinput');
    micSelect.innerHTML = mics.map(d=>`<option value="${d.deviceId}">${d.label || 'マイク'}</option>`).join('');
    const savedId = localStorage.getItem('preferred_mic_id');
    if (savedId && mics.some(m=>m.deviceId===savedId)) micSelect.value = savedId;
  }
  micSelect.addEventListener('change', ()=>{ localStorage.setItem('preferred_mic_id', micSelect.value || ''); });

  // ===== メーター初期化（選択マイク） =====
  async function initMicAndMeters(){
    if (micStream) return micStream;
    const deviceId = micSelect.value;
    micStream = await navigator.mediaDevices.getUserMedia({
      audio:{
        deviceId: deviceId ? { exact: deviceId } : undefined,
        echoCancellation:true, noiseSuppression:true, autoGainControl:true,
        channelCount:1, sampleRate:48000
      }
    });

    const AC = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AC();
    const source = audioCtx.createMediaStreamSource(micStream);
    analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048;
    timeData = new Uint8Array(analyser.fftSize); source.connect(analyser);

    wave.width = wave.clientWidth * devicePixelRatio;
    wave.height = wave.clientHeight * devicePixelRatio;

    const loop = () => {
      analyser.getByteTimeDomainData(timeData);
      let sum=0; for (let i=0;i<timeData.length;i++){ const v=(timeData[i]-128)/128; sum += v*v; }
      const rms=Math.sqrt(sum/timeData.length), level=Math.min(1, rms*4);
      levelBar.style.width = (level*100).toFixed(0)+'%';
      micBubble.classList.toggle('on', level>0.04);
      micBubble.style.transform = `scale(${(1+Math.min(0.25, level*0.8)).toFixed(3)})`;

      const W=wave.width, H=wave.height, mid=H/2; const ctx=wctx; ctx.clearRect(0,0,W,H);
      ctx.lineWidth=2*devicePixelRatio; ctx.strokeStyle='#2563eb';
      ctx.beginPath(); const step=Math.ceil(timeData.length/W);
      for(let x=0,i=0;x<W;x++,i+=step){
        const yv=(timeData[Math.min(i,timeData.length-1)]-128)/128;
        const y=mid + yv*(H/2 - 4*devicePixelRatio);
        if(x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();

      rafId = requestAnimationFrame(loop);
    };
    rafId = requestAnimationFrame(loop);
    return micStream;
  }

  function stopMicAndMeters(){
    if (rafId) cancelAnimationFrame(rafId), rafId=null;
    if (audioCtx) audioCtx.close().catch(()=>{});
    micBubble.style.transform='scale(1)'; micBubble.classList.remove('on');
  }

  // ===== 再接続（指数バックオフ） =====
  function restartWithBackoff(rec){
    const delay = Math.min(30000, 500 * Math.pow(2, retryCount)) + Math.floor(Math.random()*300);
    retryCount++;
    setStatus(`再接続中... (${retryCount})`);
    setTimeout(()=>{ try{ rec.start(); }catch{} }, delay);
  }

  // ===== 音声認識（日本語固定・重複防止） =====
  function createRecognizer(){
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR) { alert('このブラウザは Web Speech API に未対応です。Chrome/Edge をお試しください。'); return null; }

    const r = new SR();
    r.lang = 'ja-JP';
    r.interimResults = true;
    r.continuous = true;
    r.maxAlternatives = 1;

    r.onstart = () => { setStatus('認識中...（lang=ja-JP）'); retryCount = 0; lastResultAt = Date.now(); };

    r.onend   = () => {
      if (!recognizing || paused) { setStatus(paused ? '一時停止中' : '停止'); return; }
      if (retryCount < MAX_RETRY) restartWithBackoff(r);
      else setStatus('接続できません（ネットワーク/拡張機能/FWを確認）');
    };

    r.onerror = (e) => {
      console.warn('Speech error:', e);
      if (!recognizing || paused) return;
      if (retryCount < MAX_RETRY) restartWithBackoff(r);
      else setStatus('接続できません（ネットワーク/拡張機能/FWを確認）');
    };

    r.onresult = (ev) => {
      let interim = '';
      for (let i = ev.resultIndex; i < ev.results.length; i++) {
        const res = ev.results[i];
        const txt = res[0].transcript;

        if (res.isFinal) {
          const cleaned = txt.trim()
            .replace(/\s+/g, ' ')
            .replace(/(です|ます)(?!。|！|？)/g, '$1。');

          // (A) 直近finalと同一ならスキップ（3秒以内は再送とみなす）
          const now = Date.now();
          if (cleaned === lastFinalText && now - lastFinalAt < 3000) {
            continue;
          }

          // (B) 暫定行があれば昇格（新しい行を増やさない）
          if (interimBodyEl && interimSegEl) {
            interimBodyEl.className = 'final';
            interimBodyEl.textContent = cleaned;
            interimSegEl = null;
            interimBodyEl = null;
            backupSave();
          } else {
            // いきなりfinalが来た場合のみ新規追加
            addSegment(cleaned, { interim: false });
          }

          lastFinalText = cleaned;
          lastFinalAt = now;

        } else {
          interim += txt;
        }
      }

      if (interim) replaceInterim(interim);
      lastResultAt = Date.now();
    };

    return r;
  }

  // ===== ウォッチドッグ：30秒間結果なし→再起動 =====
  setInterval(()=>{
    if (recognizing && !paused && Date.now() - lastResultAt > 30000) {
      try { recognizer.stop(); } catch {}
      // onend → 再接続フローへ
    }
  }, 5000);

  // ===== ボタン動作 =====
  btnStart.onclick = async () => {
    if (recognizing) return;
    backupLoad(); startTime = Date.now();

    try { await initMicAndMeters(); }
    catch (e) { alert('マイク権限をご確認ください（🔒→サイトの設定）'); console.error(e); return; }

    recognizer = createRecognizer(); if (!recognizer) return;
    recognizing = true; paused = false;

    btnStart.disabled = true; btnPause.disabled = false; btnResume.disabled = true; btnStop.disabled = false;
    try { recognizer.start(); } catch(e){}
    setStatus('認識中...（lang=ja-JP）');
  };

  btnPause.onclick = () => {
    if (!recognizing || paused) return;
    paused = true;
    try { recognizer.stop(); } catch{}
    setStatus('一時停止中');
    btnPause.disabled = true; btnResume.disabled = false;
  };

  btnResume.onclick = () => {
    if (!recognizing || !paused) return;
    paused = false;
    try { recognizer.start(); } catch{}
    setStatus('認識中...（lang=ja-JP）');
    btnPause.disabled = false; btnResume.disabled = true;
  };

  btnStop.onclick = () => {
    recognizing = false; paused = false;
    try { recognizer.stop(); } catch{}
    stopMicAndMeters();
    btnStart.disabled = false; btnPause.disabled = true; btnResume.disabled = true; btnStop.disabled = true;
    setStatus('停止');
    backupSave();
  };

  btnQuickSave.onclick = () => quickSaveSnapshot();
  btnCopy.onclick      = () => copyAll();
  btnClear.onclick     = () => {
    if (!confirm('すべて削除しますか？')) return;
    logEl.innerHTML = '';
    localStorage.removeItem('transcript_html_v1');
    setStatus('削除しました'); setTimeout(()=>setStatus('待機中'), 1500);
  };

  // 初期化：マイク一覧
  (async () => { await listMics(); })();
})();
</script>
</body>
</html>
